<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰‹å†™å­—ä½“ç”Ÿæˆå™¨</title>
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js"></script>
    
    <style>
        :root { --primary-color: #4a90e2; --bg-color: #f5f5f5; --panel-bg: #ffffff; --text-color: #333; --border-color: #ddd; --success-color: #e8f5e9; --success-border: #a5d6a7; --success-text: #2e7d32;}
        body { font-family: "PingFang SC", "Microsoft YaHei", sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; user-select: none; overscroll-behavior: none; }
        
        /* æŒ‰é’®æ ·å¼ */
        .butt { display: inline-flex; justify-content: center; align-items: center; width: 44px; height: 44px; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; font-size: 1.4rem; margin: 0 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.1s; }
        .butt:active { transform: scale(0.92); background: #e0e0e0; }
        .butt.active { background: #333; color: #fff; border-color: #333; }

        /* è®©è®¾ç½®ã€å¤‡ä»½ã€å¯¼å…¥æŒ‰é’®å®½åº¦è‡ªé€‚åº” */
        #settingButton, #saveJsonButton, #loadJsonButton {
            width: auto;
            padding: 0 10px;
        }
        
        /* å¸ƒå±€ */
        #list-container, #demo-container, #slider-container, #button-container, #navi-container { margin-bottom: 12px; display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 8px; width: 100%; max-width: 600px; }
        
        /* ç”»å¸ƒåŒºåŸŸ */
        #canvas-frame { position: relative; width: 320px; height: 320px; margin: 10px auto; display: flex; justify-content: center; align-items: center; z-index: 10; border: 1px dashed #ccc; }
        #canvas-wrapper { position: relative; width: 320px; height: 320px; border: 1px solid #999; background: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.15); overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; touch-action: none; }
        #gridCanvas { z-index: 1; pointer-events: none; }
        #drawingCanvas { z-index: 2; cursor: crosshair; }

        /* æ§ä»¶ */
        select, input[type=text], input[type=number] { padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); font-size: 1rem; }
        .control-group { display: flex; align-items: center; background: #fff; padding: 5px 10px; border-radius: 20px; border: 1px solid #eee; margin: 5px; }
        .control-group label { margin-right: 5px; font-size: 0.9rem; white-space: nowrap;}
        input[type=range] { width: 100px; }
        
        /* å¼¹çª—ç³»ç»Ÿ */
        .dialog { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; justify-content: center; align-items: center; }
        .dialog.active { display: flex; }
        .dialog-body { background: #fff; padding: 20px; border-radius: 12px; width: 90%; max-width: 500px; max-height: 85vh; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; position: relative; box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; cursor: pointer; color: #888; }
        
        /* è®¾ç½®é¢æ¿ç‰¹æœ‰æ ·å¼ */
        .setting-item { display: flex; flex-direction: column; gap: 5px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .setting-item label { font-weight: bold; font-size: 0.9rem; color: #555; }
        .setting-row { display: flex; align-items: center; gap: 10px; justify-content: space-between; }
        .setting-val { font-size: 0.9rem; color: var(--primary-color); font-family: monospace; width: 40px; text-align: right; }

        /* é¢„è§ˆç½‘æ ¼ */
        #preview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)); gap: 5px; margin-top: 10px; }
        .char-cell { width: 100%; aspect-ratio: 1; display: flex; justify-content: center; align-items: center; border: 1px solid #eee; border-radius: 4px; font-size: 1.5rem; cursor: pointer; background: #fff; overflow: hidden; }
        .char-cell.done { border: 2px solid var(--success-text); }
        .char-cell svg { width: 100%; height: 100%; display: block; }
        .char-cell.current { border: 2px solid var(--primary-color); box-shadow: 0 0 5px var(--primary-color); }
        
        textarea { width: 100%; height: 150px; padding: 10px; box-sizing: border-box; }
        .loading-mask { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 4000; color: white; justify-content: center; align-items: center; flex-direction: column; }
        
        #downloadTTFButton { background: var(--primary-color); color: white; border: none; padding: 0 20px; font-size: 1rem; width: auto; }
    </style>
</head>
<body>

    <div id="initLoadingMask" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 5000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
        <h2 style="color: #4a90e2;">æ­£åœ¨åŠ è½½å­—åº“æ•°æ®...</h2>
        <p>è¯·ç¡®ä¿ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨ (localhost) è¿è¡Œæ­¤ç½‘é¡µ</p>
    </div>

    <div id="list-container">
        <select id="listSelect" style="max-width: 200px;">
            <option value="general1">é€šç”¨è§„èŒƒä¸€çº§ (3500å­—)</option>
            <option value="general2">é€šç”¨è§„èŒƒäºŒçº§ (3000å­—)</option>
            <option value="punctuations">æ ‡ç‚¹ç¬¦å·</option>
            <option value="custom">ğŸ“ è‡ªå®šä¹‰/ç²˜è´´...</option>
        </select>
        <span class="butt" id="canvasListButton" title="é¢„è§ˆå…¨è¡¨">ğŸ‘“</span>
        <div style="font-size: 0.85rem; color: #666; margin-left: 10px;">
            <span id="progressText">0 / 0</span>
        </div>
    </div>

    <div id="demo-container">
        <span class="butt" id="prevButton">ğŸ‘ˆ</span>
        <div style="text-align: center; min-width: 120px;">
            <div id="glyphName" style="font-size: 0.85rem; color: #666; font-family: monospace;">Loading...</div>
            <span id="charSeq" style="color:#d00; font-size: 3.5rem; line-height: 1; font-family: KaiTi, STKaiti, serif;">...</span>
        </div>
        <span class="butt" id="nextButton">ğŸ‘‰</span>
    </div>

    <div id="canvas-frame">
        <div id="canvas-wrapper">
            <canvas id="gridCanvas" width="320" height="320"></canvas>
            <canvas id="drawingCanvas" width="320" height="320"></canvas>
        </div>
    </div>

    <!-- æŒ‰é’®å®¹å™¨ç§»åˆ°ç”»å¸ƒä¸‹æ–¹ï¼Œç´§æŒ¨ç”»å¸ƒ -->
    <div id="button-container">
        <span class="butt" id="undoButton" title="æ’¤é”€">â†©ï¸</span>
        <span class="butt" id="clearButton" title="æ¸…ç©º">ğŸ—‘ï¸</span>
        <span style="border-left:1px solid #ccc; height:20px; margin:0 5px;"></span>
        <span class="butt" id="moveLeftButton">â¬…ï¸</span>
        <span class="butt" id="moveRightButton">â¡ï¸</span>
        <span class="butt" id="moveUpButton">â¬†ï¸</span>
        <span class="butt" id="moveDownButton">â¬‡ï¸</span>
    </div>

    <div id="slider-container">
        <div class="control-group">
            <span class="butt active" id="penButton">ğŸ–Œï¸</span>
            <span class="butt" id="eraserButton">ğŸš¿</span>
        </div>
        <div class="control-group">
            <label>ç²—ç»†</label>
            <input id="lineWidthSlider" type="range" min="4" max="40" value="16" />
        </div>
        <div class="control-group" style="border-color: #4a90e2;">
            <label style="color:#4a90e2">ğŸ” ç¼©æ”¾</label>
            <input id="zoomSlider" type="range" min="0.4" max="2.0" step="0.1" value="1.0" />
            <span id="zoomValue" style="font-size: 0.8rem; color: #4a90e2; width: 30px;">1.0x</span>
        </div>
    </div>

    <div id="navi-container">
        <span class="butt" id="settingButton" title="é«˜çº§è®¾ç½®" style="background:#fff3e0; border-color:#ffcc80;">âš™ï¸ è®¾ç½®</span>
        <button class="butt" id="downloadTTFButton">ğŸ’¾ ç”Ÿæˆ TTF</button>
        <span class="butt" id="saveJsonButton" title="å¤‡ä»½å·¥ç¨‹">ğŸ“‚ å¤‡ä»½</span>
        <input type="file" id="loadJsonInput" accept=".json" style="display:none">
        <span class="butt" id="loadJsonButton" onclick="document.getElementById('loadJsonInput').click()" title="å¯¼å…¥å¤‡ä»½">ğŸ“¥ å¯¼å…¥</span>
    </div>

    <!-- æµ‹è¯•é¢„è§ˆåŒºåŸŸ -->
    <div id="test-container" style="margin-top:20px; width:100%; max-width:600px; display: flex; flex-direction: column;">
        <textarea id="testInput" rows="3" placeholder="è¾“å…¥æ–‡å­—æµ‹è¯•ï¼ˆæ”¯æŒæ¢è¡Œï¼‰..." 
            style="width:100%; padding:8px; border:1px solid #ddd; border-radius:5px; resize:vertical; box-sizing:border-box; margin-bottom:8px; order:2;"></textarea>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; order:2;">
            <button id="refreshTestBtn" class="butt" style="width:auto; padding:0 15px;">é¢„è§ˆ</button>
            <div class="control-group" style="margin:0;">
                <label style="font-size:0.9rem;">ğŸ” é¢„è§ˆç¼©æ”¾</label>
                <input id="testZoomSlider" type="range" min="0.2" max="1.0" step="0.1" value="1.0" style="width:80px;">
                <span id="testZoomValue" style="font-size:0.8rem; min-width:40px;">1.0x</span>
            </div>
        </div>
        <canvas id="testCanvas" width="350" height="200" style="border:1px solid #ccc; margin-top:600px; margin-left:40px; background:#fff; border-radius:5px; order:1;"></canvas>
    </div>

    <div id="settingsDialog" class="dialog">
        <div class="dialog-body">
            <span class="close-btn" onclick="closeDialog('settingsDialog')">Ã—</span>
            <h3>âš™ï¸ å­—ä½“ & ç¬”åˆ·è®¾ç½®</h3>
            
            <div class="setting-item">
                <label>å­—ä½“ä¿¡æ¯ (å¯¼å‡ºç”¨)</label>
                <div class="setting-row">
                    <input type="text" id="fontNameInput" placeholder="è‹±æ–‡å (å¦‚ MyFont)" value="MyHandwriting">
                    <input type="text" id="fontFamilyInput" placeholder="ä¸­æ–‡å (å¦‚ æˆ‘çš„æ‰‹å†™ä½“)" value="æˆ‘çš„æ‰‹å†™ä½“">
                </div>
            </div>

            <div class="setting-item">
                <label>ğŸ–Šï¸ åŸºç¡€ç²—ç»† (Base Width)</label>
                <div class="setting-row">
                    <input type="range" id="set_baseWidth" min="4" max="50" value="16" style="flex:1">
                    <span class="setting-val" id="val_baseWidth">16</span>
                </div>
            </div>

            <div class="setting-item">
                <label>ğŸŒŠ ç¬”å‹æ•æ„Ÿåº¦ (Simulated Pressure)</label>
                <div class="setting-row">
                    <input type="range" id="set_pressure" min="0" max="100" value="60" style="flex:1">
                    <span class="setting-val" id="val_pressure">60%</span>
                </div>
                <div style="font-size:0.8rem; color:#888;">æ•°å€¼è¶Šé«˜ï¼Œä¹¦å†™é€Ÿåº¦è¶Šå¿«æ—¶çº¿æ¡è¶Šç»†ã€‚</div>
            </div>

            <div class="setting-item">
                <label>ğŸ–Œï¸ ç¬”ç”»é”¥åº¦ (Taper / Start & End)</label>
                <div class="setting-row">
                    <input type="range" id="set_taper" min="0" max="100" value="40" style="flex:1">
                    <span class="setting-val" id="val_taper">40%</span>
                </div>
                <div style="font-size:0.8rem; color:#888;">è®©ç¬”ç”»çš„èµ·ç¬”å’Œæ”¶ç¬”å¤„è‡ªç„¶å˜å°–ã€‚</div>
            </div>
            <div class="setting-item">
                <label>ğŸ“ å­—å½¢å®½åº¦ (advanceWidth)</label>
                <div class="setting-row">
                    <input type="range" id="set_glyphWidth" min="600" max="1400" value="1000" step="10" style="flex:1">
                    <span class="setting-val" id="val_glyphWidth">1000</span>
                </div>
                <div style="font-size:0.8rem; color:#888;">æ¯ä¸ªå­—ç¬¦å ç”¨çš„æ°´å¹³ç©ºé—´ï¼ˆå­—ä½“å•ä½ï¼‰ï¼Œå€¼è¶Šå¤§å­—ç¬¦é—´è·è¶Šå¤§ã€‚</div>
            </div>

            <button onclick="closeDialog('settingsDialog')" style="margin-top:10px; padding:10px; background:var(--primary-color); color:white; border:none; border-radius:5px;">å®Œæˆè®¾ç½®</button>
        </div>
    </div>

    <div id="listup-container" class="dialog">
        <div class="dialog-body">
            <span class="close-btn" onclick="closeDialog('listup-container')">Ã—</span>
            <h3>å­—è¡¨é¢„è§ˆ</h3>
            <div id="preview-grid"></div>
        </div>
    </div>

    <div id="customDialog" class="dialog">
        <div class="dialog-body">
            <h3>ç²˜è´´è‡ªå®šä¹‰æ–‡å­—</h3>
            <textarea id="customTextInput" placeholder="åœ¨æ­¤ç²˜è´´..."></textarea>
            <div style="display:flex; justify-content:flex-end; gap:10px;">
                <button onclick="closeDialog('customDialog')">å–æ¶ˆ</button>
                <button onclick="applyCustomText()" style="background:var(--primary-color); color:#fff; border:none; padding:8px 15px; border-radius:5px;">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <div id="loadingMask" class="loading-mask">
        <div style="font-size: 2rem;">âš™ï¸</div>
        <p>æ­£åœ¨æ‰“åŒ…å­—ä½“...</p>
    </div>

    <script>
        // ================= 1. æ•°æ®åŠ è½½ =================
        async function loadTxt(path) {
            try {
                const res = await fetch(path);
                if (!res.ok) throw new Error("Load failed");
                return (await res.text()).replace(/\s+/g, "");
            } catch (e) { return ""; }
        }

        async function loadData() {
            try {
                const [general1, general2] = await Promise.all([
                    loadTxt("data/level-1.txt"),  
                    loadTxt("data/level-2.txt")
                ]);
                return {
                    general1: general1 || "åŠ è½½å¤±è´¥",
                    general2: general2 || "åŠ è½½å¤±è´¥",
                    punctuations: "ï¼Œã€‚ã€ï¼›ï¼šï¼Ÿï¼â€¦â€¦â€œâ€â€˜â€™ï¼ˆï¼‰ã€ã€‘ã€Šã€‹â€”â€”-ï½Â·"
                };
            } catch (err) {
                alert("è¯·ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œ!");
                return null;
            }
        }

        // ================= 2. å…¨å±€çŠ¶æ€ä¸è®¾ç½® =================
        let appSettings = {
            baseWidth: 16,
            pressure: 0.6, // 0.0 - 1.0 (velocity influence)
            taper: 0.4,    // 0.0 - 1.0 (length percentage)
            fontNameEn: "MyHandwriting",
            fontNameZh: "æˆ‘çš„æ‰‹å†™ä½“",
            glyphWidth: 1000 
        };

        let charDatasets = {}; 
        let allGlyphData = {}; // ç»“æ„: { char: [ {points:[{x,y,w},...], isEraser} ] }
        let currentListKey = 'general1';
        let charList = "";
        let currentIndex = 0;
        let isDrawing = false;
        let currentStrokePoints = []; // ä¸´æ—¶å­˜å‚¨ç‚¹ {x, y, time}
        let isEraser = false;
        
        let canvasScale = 1.0; 
        const CANVAS_SIZE = 320;
        const CENTER = CANVAS_SIZE / 2;

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvas-wrapper');

        // ================= 3. åˆå§‹åŒ– =================
        (async function initApp() {
            const data = await loadData();
            if (data) {
                charDatasets = data;
                document.getElementById('initLoadingMask').style.display = 'none';
                charList = charDatasets[currentListKey];
                initCanvasEvents();
                drawGrid();
                updateUI();
                syncSettingsToUI();
            }
        })();

        // ================= 4. è®¾ç½®é€»è¾‘ =================
        function syncSettingsToUI() {
            document.getElementById('set_baseWidth').value = appSettings.baseWidth;
            document.getElementById('val_baseWidth').innerText = appSettings.baseWidth;
            document.getElementById('lineWidthSlider').value = appSettings.baseWidth; // åŒæ­¥ä¸»ç•Œé¢æ»‘å—

            document.getElementById('set_pressure').value = appSettings.pressure * 100;
            document.getElementById('val_pressure').innerText = Math.round(appSettings.pressure * 100) + '%';

            document.getElementById('set_taper').value = appSettings.taper * 100;
            document.getElementById('val_taper').innerText = Math.round(appSettings.taper * 100) + '%';

            document.getElementById('set_glyphWidth').value = appSettings.glyphWidth;
            document.getElementById('val_glyphWidth').innerText = appSettings.glyphWidth;
        }

        // ç»‘å®šè®¾ç½®é¢æ¿äº‹ä»¶
        document.getElementById('settingButton').onclick = () => document.getElementById('settingsDialog').classList.add('active');
        
        document.getElementById('set_baseWidth').oninput = function() {
            appSettings.baseWidth = parseInt(this.value);
            document.getElementById('val_baseWidth').innerText = this.value;
            document.getElementById('lineWidthSlider').value = this.value; // åŒæ­¥å¤–éƒ¨
        };
        // å¤–éƒ¨æ»‘å—åŒæ­¥å›è®¾ç½®
        document.getElementById('lineWidthSlider').oninput = function() {
            appSettings.baseWidth = parseInt(this.value);
            document.getElementById('set_baseWidth').value = this.value;
            document.getElementById('val_baseWidth').innerText = this.value;
        };

        document.getElementById('set_pressure').oninput = function() {
            appSettings.pressure = parseInt(this.value) / 100;
            document.getElementById('val_pressure').innerText = this.value + '%';
        };
        document.getElementById('set_taper').oninput = function() {
            appSettings.taper = parseInt(this.value) / 100;
            document.getElementById('val_taper').innerText = this.value + '%';
        };
        document.getElementById('fontNameInput').oninput = function() { appSettings.fontNameEn = this.value; };
        document.getElementById('fontFamilyInput').oninput = function() { appSettings.fontNameZh = this.value; };
        document.getElementById('set_glyphWidth').oninput = function() {
            appSettings.glyphWidth = parseInt(this.value);
            document.getElementById('val_glyphWidth').innerText = this.value;
        };

        // ================= 5. æ ¸å¿ƒç»˜å›¾ (å¸¦å‹æ„Ÿå’Œé”¥åº¦) =================

        function applyTransform(context) {
            context.save();
            context.translate(CENTER, CENTER);
            context.scale(canvasScale, canvasScale);
            context.translate(-CENTER, -CENTER);
        }

        function getVirtualPos(e) {
            const rect = canvas.getBoundingClientRect();
            let cx = e.clientX, cy = e.clientY;
            if(e.touches && e.touches.length) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
            
            // è®¡ç®—è™šæ‹Ÿåæ ‡
            const screenX = cx - rect.left;
            const screenY = cy - rect.top;
            const virtualX = (screenX - CENTER) / canvasScale + CENTER;
            const virtualY = (screenY - CENTER) / canvasScale + CENTER;
            
            return { x: virtualX, y: virtualY, time: Date.now() };
        }

        function start(e) {
            e.preventDefault(); 
            isDrawing = true; 
            currentStrokePoints = [];
            const pos = getVirtualPos(e);
            // åˆå§‹ç‚¹åŠ å…¥ä¸€ä¸ªåŸºç¡€å®½åº¦
            pos.w = appSettings.baseWidth; 
            currentStrokePoints.push(pos);
            
            renderCanvas(); // å®æ—¶é‡ç»˜
        }
        
        function move(e) {
            if(!isDrawing) return; 
            e.preventDefault();
            const pos = getVirtualPos(e);
            
            // === å‹æ„Ÿè®¡ç®—é€»è¾‘ ===
            const lastPt = currentStrokePoints[currentStrokePoints.length - 1];
            const dist = Math.hypot(pos.x - lastPt.x, pos.y - lastPt.y);
            const timeDiff = pos.time - lastPt.time;
            
            // é€Ÿåº¦ (pixels/ms)
            const velocity = timeDiff > 0 ? dist / timeDiff : 0;
            
            // åŠ¨æ€å®½åº¦ç®—æ³•: é€Ÿåº¦è¶Šå¿«ï¼Œå®½åº¦è¶Šç»†
            // ç³»æ•° 2 æ˜¯ç»éªŒå€¼ï¼Œå¯å¾®è°ƒ
            let targetWidth = appSettings.baseWidth * (1 - velocity * appSettings.pressure * 0.5); 
            // é™åˆ¶æœ€å°å®½åº¦
            targetWidth = Math.max(targetWidth, appSettings.baseWidth * 0.2);
            
            // å¹³æ»‘å¤„ç†ï¼šæ–°å®½åº¦ = æ—§å®½åº¦ * 0.6 + æ–°ç›®æ ‡ * 0.4
            pos.w = lastPt.w * 0.6 + targetWidth * 0.4;

            currentStrokePoints.push(pos);
            renderCanvas(); 
        }
        
        function end(e) {
            if(!isDrawing) return; 
            isDrawing = false;
            
            // === é”¥åº¦å¤„ç† (Tapering) ===
            // ç»“æŸåå¯¹æ•´æ¡çº¿çš„å¤´å°¾è¿›è¡Œä¿®é¥°
            if (currentStrokePoints.length > 5 && appSettings.taper > 0) {
                const len = currentStrokePoints.length;
                const taperLen = Math.floor(len * appSettings.taper * 0.5); // å•ä¾§é”¥åº¦é•¿åº¦
                const maxTaper = Math.min(taperLen, 10); // é™åˆ¶æœ€å¤§é”¥åº¦ç‚¹æ•°

                for (let i = 0; i < maxTaper; i++) {
                    const factor = (i + 1) / (maxTaper + 1); // 0.1 -> 1.0
                    // å¤´éƒ¨å˜ç»†
                    currentStrokePoints[i].w *= factor;
                    // å°¾éƒ¨å˜ç»†
                    currentStrokePoints[len - 1 - i].w *= factor;
                }
            }

            const char = charList[currentIndex];
            if (!allGlyphData[char]) allGlyphData[char] = [];
            
            if(currentStrokePoints.length > 1) {
                allGlyphData[char].push({
                    points: JSON.parse(JSON.stringify(currentStrokePoints)), // æ­¤æ—¶ç‚¹é‡Œå·²ç»åŒ…å«äº† w (width)
                    width: appSettings.baseWidth, // ä¿ç•™åŸºç¡€å®½åº¦åšå‚è€ƒ
                    isEraser: isEraser
                });
            }
            renderCanvas();
        }

        function renderCanvas() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const char = charList[currentIndex];
            const savedStrokes = allGlyphData[char] || [];
            
            // åˆå¹¶å·²ä¿å­˜çš„ç¬”ç”»å’Œå½“å‰æ­£åœ¨ç”»çš„ç¬”ç”»
            const strokesToRender = [...savedStrokes];
            if (isDrawing && currentStrokePoints.length > 0) {
                strokesToRender.push({
                    points: currentStrokePoints,
                    isEraser: isEraser,
                    width: appSettings.baseWidth
                });
            }

            applyTransform(ctx);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            strokesToRender.forEach(stroke => {
                const pts = stroke.points;
                if (pts.length < 1) return;

                ctx.strokeStyle = stroke.isEraser ? '#ffffff' : '#000000';
                ctx.globalCompositeOperation = stroke.isEraser ? 'destination-out' : 'source-over';

                // === ç»˜åˆ¶å˜å®½çº¿æ¡ (æ¨¡æ‹Ÿ) ===
                // Canvas åŸç”Ÿ stroke ä¸æ”¯æŒå˜å®½ï¼Œä¸ºäº†æ€§èƒ½å’Œæ•ˆæœï¼Œè¿™é‡Œä½¿ç”¨â€œåœ†ç‚¹+è¿çº¿â€æ··åˆ
                // æˆ–è€…ç®€å•ä½¿ç”¨ lineTo ä½†ä¸æ–­æ”¹å˜ lineWidth (æ•ˆæœä¸€èˆ¬ä¼šæ–­è£‚)
                // æœ€ä½³æ–¹æ¡ˆæ˜¯ç»˜åˆ¶è·¯å¾„è½®å»“ï¼Œä½†å¤ªæ…¢ã€‚
                // å¦¥åæ–¹æ¡ˆï¼šæ¯æ®µç”»ä¸€æ¡çº¿ï¼Œå®½åº¦å–ä¸¤ç‚¹å¹³å‡å€¼
                
                for (let i = 0; i < pts.length - 1; i++) {
                    const p1 = pts[i];
                    const p2 = pts[i+1];
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    
                    // ä½¿ç”¨ä¸¤ç‚¹å¹³å‡å®½åº¦
                    // å¦‚æœæ˜¯æ©¡çš®æ“¦ï¼Œå›ºå®šä½¿ç”¨åŸºç¡€å®½åº¦
                    ctx.lineWidth = stroke.isEraser ? stroke.width : (p1.w + p2.w) / 2;
                    ctx.stroke();
                    
                    // è¡¥åœ†å¤´é˜²æ­¢æ–­è£‚
                    ctx.beginPath();
                    ctx.arc(p2.x, p2.y, ctx.lineWidth/2, 0, Math.PI*2);
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.fill();
                }
            });
            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';
        }

        
        // ================= 6. TTF ç”Ÿæˆç®—æ³• (æ”¯æŒå˜å®½ + åŠ¨æ€å­—è·) =================
        function generateAndDownloadFont() {
            const FIXED_ADVANCE = appSettings.glyphWidth;  // ä»è®¾ç½®è¯»å–
            const glyphs = [];
            const notdefPath = new opentype.Path();
            notdefPath.moveTo(200, 0); notdefPath.lineTo(200, 700); notdefPath.lineTo(800, 700); notdefPath.lineTo(800, 0); notdefPath.close();
            glyphs.push(new opentype.Glyph({ name: '.notdef', unicode: 0, advanceWidth: FIXED_ADVANCE, path: notdefPath }));

            const SCALE = 1000 / CANVAS_SIZE;

            for (let char in allGlyphData) {
                const strokes = allGlyphData[char];
                if (!strokes || strokes.length === 0) continue;

                // ---------- ç¬¬ä¸€éï¼šæ”¶é›†æ‰€æœ‰è½®å»“ç‚¹ï¼Œè®¡ç®—åŸå§‹å®½åº¦èŒƒå›´ ----------
                let allPoints = [];
                let minX = Infinity, maxX = -Infinity;

                strokes.forEach(stroke => {
                    if (stroke.isEraser) return;
                    const pts = stroke.points;
                    if (pts.length < 2) return;

                    for (let i = 0; i < pts.length - 1; i++) {
                        const p1 = pts[i];
                        const p2 = pts[i + 1];
                        const dx = p2.x - p1.x, dy = p2.y - p1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        if (len === 0) continue;

                        const nx = -dy / len, ny = dx / len;
                        const toFontX = (cx) => cx * SCALE;
                        const toFontY = (cy) => (CANVAS_SIZE - cy) * SCALE - 200;

                        const w1 = (p1.w || stroke.width) / 2;
                        const w2 = (p2.w || stroke.width) / 2;

                        const leftP1 = { x: toFontX(p1.x + nx * w1), y: toFontY(p1.y + ny * w1) };
                        const leftP2 = { x: toFontX(p2.x + nx * w2), y: toFontY(p2.y + ny * w2) };
                        const rightP1 = { x: toFontX(p1.x - nx * w1), y: toFontY(p1.y - ny * w1) };
                        const rightP2 = { x: toFontX(p2.x - nx * w2), y: toFontY(p2.y - ny * w2) };

                        [leftP1, leftP2, rightP1, rightP2].forEach(pt => {
                            allPoints.push(pt);
                            minX = Math.min(minX, pt.x);
                            maxX = Math.max(maxX, pt.x);
                        });
                    }
                });

                if (allPoints.length === 0) continue;

                const width = maxX - minX;
                // è®¡ç®—æ°´å¹³åç§»é‡ï¼Œä½¿å­—å½¢å±…ä¸­äº FIXED_ADVANCE å®½åº¦å†…
                const dx = (FIXED_ADVANCE - width) / 2 - minX;

                // ---------- ç¬¬äºŒéï¼šæ„å»ºå­—å½¢è·¯å¾„ï¼Œåº”ç”¨å±…ä¸­å¹³ç§» ----------
                const fontPath = new opentype.Path();

                strokes.forEach(stroke => {
                    if (stroke.isEraser) return;
                    const pts = stroke.points;
                    if (pts.length < 2) return;

                    const leftSide = [], rightSide = [];
                    for (let i = 0; i < pts.length - 1; i++) {
                        const p1 = pts[i];
                        const p2 = pts[i + 1];
                        const dxLine = p2.x - p1.x, dy = p2.y - p1.y;
                        const len = Math.sqrt(dxLine * dxLine + dy * dy);
                        if (len === 0) continue;

                        const nx = -dy / len, ny = dxLine / len;
                        const toFontX = (cx) => cx * SCALE + dx; // åº”ç”¨å±…ä¸­å¹³ç§»
                        const toFontY = (cy) => (CANVAS_SIZE - cy) * SCALE - 200;

                        const w1 = (p1.w || stroke.width) / 2;
                        const w2 = (p2.w || stroke.width) / 2;

                        const leftP1 = { x: toFontX(p1.x + nx * w1), y: toFontY(p1.y + ny * w1) };
                        const leftP2 = { x: toFontX(p2.x + nx * w2), y: toFontY(p2.y + ny * w2) };
                        const rightP1 = { x: toFontX(p1.x - nx * w1), y: toFontY(p1.y - ny * w1) };
                        const rightP2 = { x: toFontX(p2.x - nx * w2), y: toFontY(p2.y - ny * w2) };

                        leftSide.push(leftP1);
                        if (i === pts.length - 2) leftSide.push(leftP2);
                        rightSide.push(rightP1);
                        if (i === pts.length - 2) rightSide.push(rightP2);
                    }

                    if (leftSide.length > 0) {
                        fontPath.moveTo(leftSide[0].x, leftSide[0].y);
                        for (let k = 1; k < leftSide.length; k++) fontPath.lineTo(leftSide[k].x, leftSide[k].y);
                        for (let k = rightSide.length - 1; k >= 0; k--) fontPath.lineTo(rightSide[k].x, rightSide[k].y);
                        fontPath.close();
                    }
                });

                const unicodeVal = char.codePointAt(0);
                glyphs.push(new opentype.Glyph({
                    name: 'uni' + unicodeVal.toString(16).toUpperCase(),
                    unicode: unicodeVal,
                    advanceWidth: FIXED_ADVANCE,
                    path: fontPath
                }));
            }

            const font = new opentype.Font({
                familyName: appSettings.fontNameEn,
                styleName: 'Regular',
                unitsPerEm: 1000,
                ascender: 800,
                descender: -200,
                glyphs: glyphs
            });
            font.names.fontFamily.en = appSettings.fontNameEn;
            font.names.fullName.en = appSettings.fontNameEn;

            try {
                const buffer = font.toArrayBuffer();
                const blob = new Blob([buffer], { type: 'application/font-sfnt' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (appSettings.fontNameEn || 'MyHandwriting') + '.ttf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (e) {
                alert('å­—ä½“ç”Ÿæˆå¤±è´¥ï¼š' + e.message);
            }
        }


        
        // ================= é€šç”¨è¾…åŠ© =================
        function updateUI() {
            if(!charList || charList.length === 0) return;
            if (currentIndex >= charList.length) currentIndex = charList.length - 1;
            
            const realChars = Array.from(charList);
            const char = realChars[currentIndex];
            document.getElementById('charSeq').innerText = char;
            const unicodeHex = char.codePointAt(0).toString(16).toUpperCase().padStart(4, '0');
            document.getElementById('glyphName').innerText = `U+${unicodeHex}`;
            document.getElementById('progressText').innerText = `${currentIndex + 1} / ${realChars.length}`;
            renderCanvas();
        }

        function drawGrid() {
            gridCtx.clearRect(0, 0, 320, 320);
            applyTransform(gridCtx); // åº”ç”¨ç¼©æ”¾å’Œå¹³ç§»

            // ---- 1. ç»˜åˆ¶å¤–è¾¹æ¡†ï¼ˆçº¢è‰²ï¼‰ ----
            gridCtx.strokeStyle = '#ffcccc';
            gridCtx.lineWidth = 1 / canvasScale;
            gridCtx.strokeRect(0, 0, 320, 320);

            // ---- 2. ç»˜åˆ¶ç±³å­—æ ¼ï¼ˆçº¢è‰²åå­—å’Œå¯¹è§’çº¿ï¼‰ ----
            gridCtx.beginPath();
            gridCtx.moveTo(160, 0); gridCtx.lineTo(160, 320);   // å‚ç›´ä¸­çº¿
            gridCtx.moveTo(0, 160); gridCtx.lineTo(320, 160);   // æ°´å¹³ä¸­çº¿
            gridCtx.moveTo(0, 0); gridCtx.lineTo(320, 320);     // å¯¹è§’çº¿
            gridCtx.moveTo(320, 0); gridCtx.lineTo(0, 320);     // å¦ä¸€æ¡å¯¹è§’çº¿
            gridCtx.strokeStyle = '#ffcccc';
            gridCtx.stroke();

            // ---- 3. ç»˜åˆ¶ä¹å®«æ ¼è¾…åŠ©çº¿ï¼ˆç°è‰²è™šçº¿ï¼‰ ----
            const third = 320 / 3; // ä¸‰ç­‰åˆ†ç‚¹åæ ‡
            gridCtx.beginPath();
            gridCtx.strokeStyle = '#cccccc';               // æµ…ç°è‰²
            gridCtx.lineWidth = 0.8 / canvasScale;         // ç»†çº¿ï¼Œé€‚åº”ç¼©æ”¾
            // è®¾ç½®è™šçº¿æ ·å¼ï¼šçº¿æ®µé•¿åº¦ 5pxï¼Œé—´éš” 3pxï¼ˆå‡æ ¹æ®ç¼©æ”¾è°ƒæ•´ï¼Œä¿æŒå±å¹•è§†è§‰ä¸€è‡´ï¼‰
            gridCtx.setLineDash([5 / canvasScale, 3 / canvasScale]);

            // å‚ç›´ä¸‰ç­‰åˆ†çº¿
            gridCtx.moveTo(third, 0); gridCtx.lineTo(third, 320);
            gridCtx.moveTo(third * 2, 0); gridCtx.lineTo(third * 2, 320);
            // æ°´å¹³ä¸‰ç­‰åˆ†çº¿
            gridCtx.moveTo(0, third); gridCtx.lineTo(320, third);
            gridCtx.moveTo(0, third * 2); gridCtx.lineTo(320, third * 2);
            gridCtx.stroke();

            // ---- 4. ç»˜åˆ¶å›å®«æ ¼å†…æ¡†ï¼ˆè“è‰²è™šçº¿ï¼‰ ----
            const innerSize = 200; // å†…æ¡†è¾¹é•¿ï¼Œå¯æ ¹æ®éœ€è¦è°ƒæ•´
            const margin = (320 - innerSize) / 2; // å±…ä¸­è¾¹è·
            gridCtx.strokeStyle = '#3366cc';       // è“è‰²
            gridCtx.lineWidth = 1 / canvasScale;
            // ä½¿ç”¨è™šçº¿ï¼ŒåŒºåˆ«äºå¤–æ¡†
            gridCtx.setLineDash([6 / canvasScale, 4 / canvasScale]);
            gridCtx.strokeRect(margin, margin, innerSize, innerSize);
            // å¯ä»¥é€‰æ‹©æ·»åŠ å†…æ¡†çš„å¯¹è§’çº¿ï¼Œä½†ä¸ºäº†ç®€æ´æš‚æ—¶ä¸åŠ 

            // æ¢å¤å®çº¿ï¼Œé¿å…å½±å“å…¶ä»–ç»˜åˆ¶
            gridCtx.setLineDash([]);
            gridCtx.restore(); // æ¢å¤ä¸Šä¸‹æ–‡å˜æ¢

        }
        function initCanvasEvents() {
            canvas.addEventListener('mousedown', start); canvas.addEventListener('mousemove', move);
            canvas.addEventListener('mouseup', end); canvas.addEventListener('mouseout', () => isDrawing=false);
            canvas.addEventListener('touchstart', start, {passive:false}); canvas.addEventListener('touchmove', move, {passive:false});
            canvas.addEventListener('touchend', end);
        }

        window.closeDialog = (id) => document.getElementById(id).classList.remove('active');
        
        // é¢„è§ˆ SVG ç”Ÿæˆ
        document.getElementById('canvasListButton').onclick = function() {
            const container = document.getElementById('preview-grid');
            container.innerHTML = '';
            const fragment = document.createDocumentFragment();
            const realChars = Array.from(charList);

            for (let i = 0; i < realChars.length; i++) {
                const char = realChars[i];
                const cell = document.createElement('div');
                cell.className = 'char-cell';
                const strokes = allGlyphData[char];

                if (strokes && strokes.length > 0) {
                    cell.classList.add('done');
                    let svgPaths = '';
                    strokes.forEach(s => {
                        const color = s.isEraser ? '#ffffff' : '#000000';
                        if(s.points && s.points.length > 0) {
                            let d = `M ${s.points[0].x} ${s.points[0].y}`;
                            // é¢„è§ˆæ—¶ç®€å•åŒ–ï¼Œä¸ç”»å˜å®½æ•ˆæœä»¥æé«˜æ€§èƒ½ï¼Œæˆ–è€…å–å¹³å‡å®½
                            for(let k=1; k < s.points.length; k++) d += ` L ${s.points[k].x} ${s.points[k].y}`;
                            // SVG é¢„è§ˆå–ç¬¬ä¸€ç‚¹çš„å®½åº¦åšå‚è€ƒ
                            const avgW = s.width; 
                            svgPaths += `<path d="${d}" stroke="${color}" stroke-width="${avgW}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
                        }
                    });
                    cell.innerHTML = `<svg viewBox="0 0 320 320">${svgPaths}</svg>`;
                } else {
                    cell.innerText = char;
                }
                
                if (i === currentIndex) cell.classList.add('current');
                cell.onclick = () => { currentIndex = i; updateUI(); closeDialog('listup-container'); };
                fragment.appendChild(cell);
            }
            container.appendChild(fragment);
            document.getElementById('listup-container').classList.add('active');
        };

        // æŒ‰é’®äº‹ä»¶
        document.getElementById('undoButton').onclick = () => { 
            const char = Array.from(charList)[currentIndex]; 
            if(allGlyphData[char]) { 
                allGlyphData[char].pop(); 
                renderCanvas(); 
                if(testInput.value) drawTestPreview(testInput.value); // æ–°å¢
            } 
        };
        document.getElementById('clearButton').onclick = () => { const char = Array.from(charList)[currentIndex]; allGlyphData[char] = []; renderCanvas(); };
        document.getElementById('prevButton').onclick = () => { if(currentIndex>0) {currentIndex--; updateUI();} };
        document.getElementById('nextButton').onclick = () => { if(currentIndex<Array.from(charList).length-1) {currentIndex++; updateUI();} };
        document.getElementById('moveLeftButton').onclick = () => moveStrokes(-10, 0);
        document.getElementById('moveRightButton').onclick = () => moveStrokes(10, 0);
        document.getElementById('moveUpButton').onclick = () => moveStrokes(0, -10);
        document.getElementById('moveDownButton').onclick = () => moveStrokes(0, 10);
        document.getElementById('downloadTTFButton').onclick = async () => {
            document.getElementById('loadingMask').style.display = 'flex';
            setTimeout(() => { try { generateAndDownloadFont(); } catch(e) { alert(e.message); } finally { document.getElementById('loadingMask').style.display = 'none'; } }, 100);
        };
        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            canvasScale = parseFloat(e.target.value);
            document.getElementById('zoomValue').innerText = canvasScale.toFixed(1) + 'x';
            drawGrid(); renderCanvas();
        });
        document.getElementById('penButton').onclick = function() { isEraser=false; this.classList.add('active'); document.getElementById('eraserButton').classList.remove('active'); };
        document.getElementById('eraserButton').onclick = function() { isEraser=true; this.classList.add('active'); document.getElementById('penButton').classList.remove('active'); };
        document.getElementById('listSelect').onchange = (e) => {
            if(e.target.value === 'custom') document.getElementById('customDialog').classList.add('active');
            else { currentListKey = e.target.value; charList = charDatasets[currentListKey]; currentIndex = 0; updateUI(); }
        };
        window.applyCustomText = function() {
            const text = document.getElementById('customTextInput').value;
            if(!text) return;
            const uniqueChars = Array.from(new Set(Array.from(text))).filter(c => c.trim() !== '');
            charDatasets['custom'] = uniqueChars.join('');
            currentListKey = 'custom'; charList = charDatasets['custom']; currentIndex = 0;
            closeDialog('customDialog'); updateUI();
        };
        const moveStrokes = (dx, dy) => {
            const char = Array.from(charList)[currentIndex];
            if(!allGlyphData[char]) return;
            allGlyphData[char].forEach(s => s.points.forEach(p => { p.x+=dx; p.y+=dy; }));
            renderCanvas();
        };
        // ================= 7. æµ‹è¯•é¢„è§ˆåŠŸèƒ½ =================
        const testInput = document.getElementById('testInput');
        const testCanvas = document.getElementById('testCanvas');
        const testCtx = testCanvas.getContext('2d');
        const refreshTestBtn = document.getElementById('refreshTestBtn');
        // é¢„è§ˆç¼©æ”¾æ§åˆ¶
        const testZoomSlider = document.getElementById('testZoomSlider');
        const testZoomValue = document.getElementById('testZoomValue');
        let testZoom = 1.0; // é»˜è®¤ç¼©æ”¾å› å­ï¼ˆåŸºäºåŸºç¡€æ¯”ä¾‹ï¼‰

        testZoomSlider.addEventListener('input', (e) => {
            testZoom = parseFloat(e.target.value);
            testZoomValue.innerText = testZoom.toFixed(1) + 'x';
            // å¦‚æœæœ‰è¾“å…¥æ–‡å­—ï¼Œç«‹å³åˆ·æ–°é¢„è§ˆ
            if (testInput.value) drawTestPreview(testInput.value);
        });

        // è®¡ç®—å•ä¸ªå­—ç¬¦çš„å®é™…å®½åº¦ï¼ˆåŸºäºç¬”ç”»ç‚¹çš„æœ€å°/æœ€å¤§ xï¼‰
        function getCharWidth(char) {
            const strokes = allGlyphData[char];
            if (!strokes || strokes.length === 0) return 100; // é»˜è®¤å®½åº¦
            let minX = Infinity, maxX = -Infinity;
            strokes.forEach(stroke => {
                if (stroke.isEraser) return; // å¿½ç•¥æ©¡çš®æ“¦ç¬”ç”»
                stroke.points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                });
            });
            if (minX === Infinity || maxX === -Infinity) return 100;
            // åŠ ä¸Šç¬”ç”»åŠå®½ä½œä¸ºå®‰å…¨è¾¹è·ï¼ˆå–æœ€å¤§ç¬”ç”»å®½åº¦çš„ä¸€åŠï¼‰
            let maxStrokeWidth = 0;
            strokes.forEach(stroke => {
                if (stroke.isEraser) return;
                stroke.points.forEach(p => {
                    if (p.w) maxStrokeWidth = Math.max(maxStrokeWidth, p.w);
                });
            });
            return (maxX - minX) + maxStrokeWidth; // å¢åŠ ç¬”ç”»å®½åº¦é¿å…è£å‰ª
        }

        // ç»˜åˆ¶æµ‹è¯•æ–‡æœ¬
        function drawTestPreview(text) {
            testCtx.clearRect(0, 0, testCanvas.width, testCanvas.height);
            if (!text) return;

            // æŒ‰æ¢è¡Œç¬¦åˆ†å‰²æ–‡æœ¬
            const lines = text.split('\n');
            
            // åŸºç¡€æ¯”ä¾‹ï¼šä½¿å­—ç¬¦é«˜åº¦å ç”»å¸ƒé«˜åº¦çš„ 80%ï¼ˆå‚è€ƒå•è¡Œï¼‰
            const baseScale = testCanvas.height / CANVAS_SIZE * 0.8;
            const scale = baseScale * testZoom;
            
            // è¡Œé«˜ = å­—ç¬¦é«˜åº¦ Ã— 1.2
            const lineHeight = CANVAS_SIZE * scale * 1.2;
            // èµ·å§‹ Y åæ ‡ï¼ˆç•™å‡ºé¡¶éƒ¨è¾¹è·ï¼‰
            let cursorY = lineHeight * 0.2;

            testCtx.lineCap = 'round';
            testCtx.lineJoin = 'round';
            testCtx.strokeStyle = '#000';
            testCtx.fillStyle = '#000';

            for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
                const line = lines[lineIdx];
                let cursorX = 20; // æ¯è¡Œå·¦è¾¹è·

                // å¦‚æœå½“å‰è¡Œèµ·å§‹ä½ç½®è¶…å‡ºç”»å¸ƒåº•éƒ¨ï¼Œåœæ­¢ç»˜åˆ¶
                if (cursorY + CANVAS_SIZE * scale > testCanvas.height) break;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const strokes = allGlyphData[char];

                    // æœªä¹¦å†™å­—ç¬¦æ˜¾ç¤ºç°è‰²å ä½æ¡†
                    if (!strokes || strokes.length === 0) {
                        testCtx.save();
                        testCtx.strokeStyle = '#ccc';
                        testCtx.lineWidth = 2;
                        testCtx.strokeRect(cursorX, cursorY, 40 * scale, 320 * scale);
                        testCtx.restore();
                        cursorX += 40 * scale + 10;
                        continue;
                    }

                    // ç»˜åˆ¶è¯¥å­—ç¬¦çš„æ‰€æœ‰ç¬”ç”»ï¼ˆå¿½ç•¥æ©¡çš®æ“¦ï¼‰
                    strokes.forEach(stroke => {
                        if (stroke.isEraser) return;
                        const pts = stroke.points;
                        if (pts.length < 2) return;

                        for (let j = 0; j < pts.length - 1; j++) {
                            const p1 = pts[j];
                            const p2 = pts[j+1];

                            testCtx.beginPath();
                            testCtx.moveTo(cursorX + p1.x * scale, cursorY + p1.y * scale);
                            testCtx.lineTo(cursorX + p2.x * scale, cursorY + p2.y * scale);

                            const w = (p1.w + p2.w) / 2;
                            testCtx.lineWidth = w * scale;
                            testCtx.stroke();

                            // è¡¥å……åœ†ç‚¹ä½¿è¿æ¥å¤„å¹³æ»‘
                            testCtx.beginPath();
                            testCtx.arc(cursorX + p2.x * scale, cursorY + p2.y * scale, (w * scale) / 2, 0, Math.PI * 2);
                            testCtx.fill();
                        }
                    });

                    // è®¡ç®—å­—ç¬¦å®½åº¦å¹¶ç§»åŠ¨å…‰æ ‡
                    const charWidth = getCharWidth(char) * scale;
                    cursorX += charWidth + 10;
                    if (cursorX > testCanvas.width - 20) break; // è¶…å‡ºç”»å¸ƒå³ä¾§åˆ™ç»ˆæ­¢è¯¥è¡Œ
                }

                // ä¸‹ä¸€è¡Œèµ·å§‹ Y åæ ‡å¢åŠ è¡Œé«˜
                cursorY += lineHeight;
            }
        }
        // ç»‘å®šé¢„è§ˆäº‹ä»¶
        refreshTestBtn.addEventListener('click', () => drawTestPreview(testInput.value));
        testInput.addEventListener('input', () => drawTestPreview(testInput.value));

        // ================= 8. å¤‡ä»½ä¸å¯¼å…¥åŠŸèƒ½ =================
        document.getElementById('saveJsonButton').addEventListener('click', function() {
            const backup = {
                version: '1.0',
                appSettings: { ...appSettings },
                allGlyphData: allGlyphData,
                currentListKey: currentListKey,
                charList: charList,
                currentIndex: currentIndex
            };
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (appSettings.fontNameEn || 'backup') + '_backup.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        document.getElementById('loadJsonInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                try {
                    const backup = JSON.parse(ev.target.result);
                    if (backup.version !== '1.0') {
                        alert('ä¸æ”¯æŒçš„å¤‡ä»½ç‰ˆæœ¬');
                        return;
                    }
                    // æ¢å¤è®¾ç½®
                    Object.assign(appSettings, backup.appSettings);
                    allGlyphData = backup.allGlyphData;
                    currentListKey = backup.currentListKey;
                    charList = backup.charList;
                    currentIndex = backup.currentIndex;
                    if (currentIndex >= charList.length) currentIndex = 0;
                    // åŒæ­¥è®¾ç½®åˆ° UI
                    syncSettingsToUI();
                    // æ›´æ–°ç•Œé¢
                    updateUI();
                    // åˆ·æ–°æµ‹è¯•é¢„è§ˆ
                    if (testInput.value) drawTestPreview(testInput.value);
                    // æ¸…é™¤æ–‡ä»¶é€‰æ‹©
                    e.target.value = '';
                } catch (err) {
                    alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message);
                }
            };
            reader.readAsText(file);
        });
    </script>
</body>
</html>