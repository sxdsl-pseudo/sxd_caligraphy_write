<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰‹å†™å­—ä½“ç”Ÿæˆå™¨ - ä¸“ä¸šç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js"></script>
    
    <style>
        :root { --primary-color: #4a90e2; --bg-color: #f5f5f5; --panel-bg: #ffffff; --text-color: #333; --border-color: #ddd; --success-color: #e8f5e9; --success-border: #a5d6a7; --success-text: #2e7d32;}
        body { font-family: "PingFang SC", "Microsoft YaHei", sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; user-select: none; overscroll-behavior: none; }
        
        /* æŒ‰é’®æ ·å¼ */
        .butt { display: inline-flex; justify-content: center; align-items: center; width: 44px; height: 44px; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; font-size: 1.4rem; margin: 0 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.1s; }
        .butt:active { transform: scale(0.92); background: #e0e0e0; }
        .butt.active { background: #333; color: #fff; border-color: #333; }
        
        /* å¸ƒå±€ */
        #list-container, #demo-container, #slider-container, #button-container, #navi-container { margin-bottom: 12px; display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 8px; width: 100%; max-width: 600px; }
        
        /* ç”»å¸ƒåŒºåŸŸ */
        #canvas-frame { position: relative; width: 320px; height: 320px; margin: 10px auto; display: flex; justify-content: center; align-items: center; z-index: 10; border: 1px dashed #ccc; }
        #canvas-wrapper { position: relative; width: 320px; height: 320px; border: 1px solid #999; background: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.15); overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; touch-action: none; }
        #gridCanvas { z-index: 1; pointer-events: none; }
        #drawingCanvas { z-index: 2; cursor: crosshair; }

        /* æ§ä»¶ */
        select, input[type=text], input[type=number] { padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); font-size: 1rem; }
        .control-group { display: flex; align-items: center; background: #fff; padding: 5px 10px; border-radius: 20px; border: 1px solid #eee; margin: 5px; }
        .control-group label { margin-right: 5px; font-size: 0.9rem; white-space: nowrap;}
        input[type=range] { width: 100px; }
        
        /* å¼¹çª—ç³»ç»Ÿ */
        .dialog { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; justify-content: center; align-items: center; }
        .dialog.active { display: flex; }
        .dialog-body { background: #fff; padding: 20px; border-radius: 12px; width: 90%; max-width: 500px; max-height: 85vh; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; position: relative; box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; cursor: pointer; color: #888; }
        
        /* è®¾ç½®é¢æ¿ç‰¹æœ‰æ ·å¼ */
        .setting-item { display: flex; flex-direction: column; gap: 5px; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .setting-item label { font-weight: bold; font-size: 0.9rem; color: #555; }
        .setting-row { display: flex; align-items: center; gap: 10px; justify-content: space-between; }
        .setting-val { font-size: 0.9rem; color: var(--primary-color); font-family: monospace; width: 40px; text-align: right; }

        /* é¢„è§ˆç½‘æ ¼ */
        #preview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)); gap: 5px; margin-top: 10px; }
        .char-cell { width: 100%; aspect-ratio: 1; display: flex; justify-content: center; align-items: center; border: 1px solid #eee; border-radius: 4px; font-size: 1.5rem; cursor: pointer; background: #fff; overflow: hidden; }
        .char-cell.done { border: 2px solid var(--success-text); }
        .char-cell svg { width: 100%; height: 100%; display: block; }
        .char-cell.current { border: 2px solid var(--primary-color); box-shadow: 0 0 5px var(--primary-color); }
        
        textarea { width: 100%; height: 150px; padding: 10px; box-sizing: border-box; }
        .loading-mask { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 4000; color: white; justify-content: center; align-items: center; flex-direction: column; }
        
        #downloadTTFButton { background: var(--primary-color); color: white; border: none; padding: 0 20px; font-size: 1rem; width: auto; }
    </style>
</head>
<body>

    <div id="initLoadingMask" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; z-index: 5000; display: flex; justify-content: center; align-items: center; flex-direction: column;">
        <h2 style="color: #4a90e2;">æ­£åœ¨åŠ è½½å­—åº“æ•°æ®...</h2>
        <p>è¯·ç¡®ä¿ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨ (localhost) è¿è¡Œæ­¤ç½‘é¡µ</p>
    </div>

    <div id="list-container">
        <select id="listSelect" style="max-width: 200px;">
            <option value="general1">é€šç”¨è§„èŒƒä¸€çº§ (3500å­—)</option>
            <option value="general2">é€šç”¨è§„èŒƒäºŒçº§ (3000å­—)</option>
            <option value="punctuations">æ ‡ç‚¹ç¬¦å·</option>
            <option value="custom">ğŸ“ è‡ªå®šä¹‰/ç²˜è´´...</option>
        </select>
        <span class="butt" id="canvasListButton" title="é¢„è§ˆå…¨è¡¨">ğŸ‘“</span>
        <div style="font-size: 0.85rem; color: #666; margin-left: 10px;">
            <span id="progressText">0 / 0</span>
        </div>
    </div>

    <div id="demo-container">
        <span class="butt" id="prevButton">ğŸ‘ˆ</span>
        <div style="text-align: center; min-width: 120px;">
            <div id="glyphName" style="font-size: 0.85rem; color: #666; font-family: monospace;">Loading...</div>
            <span id="charSeq" style="color:#d00; font-size: 3.5rem; line-height: 1; font-family: KaiTi, STKaiti, serif;">...</span>
        </div>
        <span class="butt" id="nextButton">ğŸ‘‰</span>
    </div>

    <div id="canvas-frame">
        <div id="canvas-wrapper">
            <canvas id="gridCanvas" width="320" height="320"></canvas>
            <canvas id="drawingCanvas" width="320" height="320"></canvas>
        </div>
    </div>

    <div id="slider-container">
        <div class="control-group">
            <span class="butt active" id="penButton">ğŸ–Œï¸</span>
            <span class="butt" id="eraserButton">ğŸš¿</span>
        </div>
        <div class="control-group">
            <label>ç²—ç»†</label>
            <input id="lineWidthSlider" type="range" min="4" max="40" value="16" />
        </div>
        <div class="control-group" style="border-color: #4a90e2;">
            <label style="color:#4a90e2">ğŸ” ç¼©æ”¾</label>
            <input id="zoomSlider" type="range" min="0.8" max="2.0" step="0.1" value="1.0" />
            <span id="zoomValue" style="font-size: 0.8rem; color: #4a90e2; width: 30px;">1.0x</span>
        </div>
    </div>

    <div id="navi-container">
        <span class="butt" id="settingButton" title="é«˜çº§è®¾ç½®" style="background:#fff3e0; border-color:#ffcc80;">âš™ï¸ è®¾ç½®</span>
        <button class="butt" id="downloadTTFButton">ğŸ’¾ ç”Ÿæˆ TTF</button>
        <span class="butt" id="saveJsonButton" title="å¤‡ä»½å·¥ç¨‹">ğŸ“‚ å¤‡ä»½</span>
        <input type="file" id="loadJsonInput" accept=".json" style="display:none">
        <span class="butt" id="loadJsonButton" onclick="document.getElementById('loadJsonInput').click()" title="å¯¼å…¥å¤‡ä»½">ğŸ“¥ å¯¼å…¥</span>
    </div>

    <div id="button-container">
        <span class="butt" id="undoButton" title="æ’¤é”€">â†©ï¸</span>
        <span class="butt" id="clearButton" title="æ¸…ç©º">ğŸ—‘ï¸</span>
        <span style="border-left:1px solid #ccc; height:20px; margin:0 5px;"></span>
        <span class="butt" id="moveLeftButton">â¬…ï¸</span>
        <span class="butt" id="moveRightButton">â¡ï¸</span>
        <span class="butt" id="moveUpButton">â¬†ï¸</span>
        <span class="butt" id="moveDownButton">â¬‡ï¸</span>
    </div>

    <div id="settingsDialog" class="dialog">
        <div class="dialog-body">
            <span class="close-btn" onclick="closeDialog('settingsDialog')">Ã—</span>
            <h3>âš™ï¸ å­—ä½“ & ç¬”åˆ·è®¾ç½®</h3>
            
            <div class="setting-item">
                <label>å­—ä½“ä¿¡æ¯ (å¯¼å‡ºç”¨)</label>
                <div class="setting-row">
                    <input type="text" id="fontNameInput" placeholder="è‹±æ–‡å (å¦‚ MyFont)" value="MyHandwriting">
                    <input type="text" id="fontFamilyInput" placeholder="ä¸­æ–‡å (å¦‚ æˆ‘çš„æ‰‹å†™ä½“)" value="æˆ‘çš„æ‰‹å†™ä½“">
                </div>
            </div>

            <div class="setting-item">
                <label>ğŸ–Šï¸ åŸºç¡€ç²—ç»† (Base Width)</label>
                <div class="setting-row">
                    <input type="range" id="set_baseWidth" min="4" max="50" value="16" style="flex:1">
                    <span class="setting-val" id="val_baseWidth">16</span>
                </div>
            </div>

            <div class="setting-item">
                <label>ğŸŒŠ ç¬”å‹æ•æ„Ÿåº¦ (Simulated Pressure)</label>
                <div class="setting-row">
                    <input type="range" id="set_pressure" min="0" max="100" value="60" style="flex:1">
                    <span class="setting-val" id="val_pressure">60%</span>
                </div>
                <div style="font-size:0.8rem; color:#888;">æ•°å€¼è¶Šé«˜ï¼Œä¹¦å†™é€Ÿåº¦è¶Šå¿«æ—¶çº¿æ¡è¶Šç»†ã€‚</div>
            </div>

            <div class="setting-item">
                <label>ğŸ–Œï¸ ç¬”ç”»é”¥åº¦ (Taper / Start & End)</label>
                <div class="setting-row">
                    <input type="range" id="set_taper" min="0" max="100" value="40" style="flex:1">
                    <span class="setting-val" id="val_taper">40%</span>
                </div>
                <div style="font-size:0.8rem; color:#888;">è®©ç¬”ç”»çš„èµ·ç¬”å’Œæ”¶ç¬”å¤„è‡ªç„¶å˜å°–ã€‚</div>
            </div>

            <button onclick="closeDialog('settingsDialog')" style="margin-top:10px; padding:10px; background:var(--primary-color); color:white; border:none; border-radius:5px;">å®Œæˆè®¾ç½®</button>
        </div>
    </div>

    <div id="listup-container" class="dialog">
        <div class="dialog-body">
            <span class="close-btn" onclick="closeDialog('listup-container')">Ã—</span>
            <h3>å­—è¡¨é¢„è§ˆ</h3>
            <div id="preview-grid"></div>
        </div>
    </div>

    <div id="customDialog" class="dialog">
        <div class="dialog-body">
            <h3>ç²˜è´´è‡ªå®šä¹‰æ–‡å­—</h3>
            <textarea id="customTextInput" placeholder="åœ¨æ­¤ç²˜è´´..."></textarea>
            <div style="display:flex; justify-content:flex-end; gap:10px;">
                <button onclick="closeDialog('customDialog')">å–æ¶ˆ</button>
                <button onclick="applyCustomText()" style="background:var(--primary-color); color:#fff; border:none; padding:8px 15px; border-radius:5px;">ç¡®å®š</button>
            </div>
        </div>
    </div>

    <div id="loadingMask" class="loading-mask">
        <div style="font-size: 2rem;">âš™ï¸</div>
        <p>æ­£åœ¨æ‰“åŒ…å­—ä½“...</p>
    </div>

    <script>
        // ================= 1. æ•°æ®åŠ è½½ =================
        async function loadTxt(path) {
            try {
                const res = await fetch(path);
                if (!res.ok) throw new Error("Load failed");
                return (await res.text()).replace(/\s+/g, "");
            } catch (e) { return ""; }
        }

        async function loadData() {
            try {
                const [general1, general2] = await Promise.all([
                    loadTxt("data/level-1.txt"),  
                    loadTxt("data/level-2.txt")
                ]);
                return {
                    general1: general1 || "åŠ è½½å¤±è´¥",
                    general2: general2 || "åŠ è½½å¤±è´¥",
                    punctuations: "ï¼Œã€‚ã€ï¼›ï¼šï¼Ÿï¼â€¦â€¦â€œâ€â€˜â€™ï¼ˆï¼‰ã€ã€‘ã€Šã€‹â€”â€”-ï½Â·"
                };
            } catch (err) {
                alert("è¯·ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œ!");
                return null;
            }
        }

        // ================= 2. å…¨å±€çŠ¶æ€ä¸è®¾ç½® =================
        let appSettings = {
            baseWidth: 16,
            pressure: 0.6, // 0.0 - 1.0 (velocity influence)
            taper: 0.4,    // 0.0 - 1.0 (length percentage)
            fontNameEn: "MyHandwriting",
            fontNameZh: "æˆ‘çš„æ‰‹å†™ä½“"
        };

        let charDatasets = {}; 
        let allGlyphData = {}; // ç»“æ„: { char: [ {points:[{x,y,w},...], isEraser} ] }
        let currentListKey = 'general1';
        let charList = "";
        let currentIndex = 0;
        let isDrawing = false;
        let currentStrokePoints = []; // ä¸´æ—¶å­˜å‚¨ç‚¹ {x, y, time}
        let isEraser = false;
        
        let canvasScale = 1.0; 
        const CANVAS_SIZE = 320;
        const CENTER = CANVAS_SIZE / 2;

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvas-wrapper');

        // ================= 3. åˆå§‹åŒ– =================
        (async function initApp() {
            const data = await loadData();
            if (data) {
                charDatasets = data;
                document.getElementById('initLoadingMask').style.display = 'none';
                charList = charDatasets[currentListKey];
                initCanvasEvents();
                drawGrid();
                updateUI();
                syncSettingsToUI();
            }
        })();

        // ================= 4. è®¾ç½®é€»è¾‘ =================
        function syncSettingsToUI() {
            document.getElementById('set_baseWidth').value = appSettings.baseWidth;
            document.getElementById('val_baseWidth').innerText = appSettings.baseWidth;
            document.getElementById('lineWidthSlider').value = appSettings.baseWidth; // åŒæ­¥ä¸»ç•Œé¢æ»‘å—

            document.getElementById('set_pressure').value = appSettings.pressure * 100;
            document.getElementById('val_pressure').innerText = Math.round(appSettings.pressure * 100) + '%';

            document.getElementById('set_taper').value = appSettings.taper * 100;
            document.getElementById('val_taper').innerText = Math.round(appSettings.taper * 100) + '%';
        }

        // ç»‘å®šè®¾ç½®é¢æ¿äº‹ä»¶
        document.getElementById('settingButton').onclick = () => document.getElementById('settingsDialog').classList.add('active');
        
        document.getElementById('set_baseWidth').oninput = function() {
            appSettings.baseWidth = parseInt(this.value);
            document.getElementById('val_baseWidth').innerText = this.value;
            document.getElementById('lineWidthSlider').value = this.value; // åŒæ­¥å¤–éƒ¨
        };
        // å¤–éƒ¨æ»‘å—åŒæ­¥å›è®¾ç½®
        document.getElementById('lineWidthSlider').oninput = function() {
            appSettings.baseWidth = parseInt(this.value);
            document.getElementById('set_baseWidth').value = this.value;
            document.getElementById('val_baseWidth').innerText = this.value;
        };

        document.getElementById('set_pressure').oninput = function() {
            appSettings.pressure = parseInt(this.value) / 100;
            document.getElementById('val_pressure').innerText = this.value + '%';
        };
        document.getElementById('set_taper').oninput = function() {
            appSettings.taper = parseInt(this.value) / 100;
            document.getElementById('val_taper').innerText = this.value + '%';
        };
        document.getElementById('fontNameInput').oninput = function() { appSettings.fontNameEn = this.value; };
        document.getElementById('fontFamilyInput').oninput = function() { appSettings.fontNameZh = this.value; };


        // ================= 5. æ ¸å¿ƒç»˜å›¾ (å¸¦å‹æ„Ÿå’Œé”¥åº¦) =================

        function applyTransform(context) {
            context.save();
            context.translate(CENTER, CENTER);
            context.scale(canvasScale, canvasScale);
            context.translate(-CENTER, -CENTER);
        }

        function getVirtualPos(e) {
            const rect = canvas.getBoundingClientRect();
            let cx = e.clientX, cy = e.clientY;
            if(e.touches && e.touches.length) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
            
            // è®¡ç®—è™šæ‹Ÿåæ ‡
            const screenX = cx - rect.left;
            const screenY = cy - rect.top;
            const virtualX = (screenX - CENTER) / canvasScale + CENTER;
            const virtualY = (screenY - CENTER) / canvasScale + CENTER;
            
            return { x: virtualX, y: virtualY, time: Date.now() };
        }

        function start(e) {
            e.preventDefault(); 
            isDrawing = true; 
            currentStrokePoints = [];
            const pos = getVirtualPos(e);
            // åˆå§‹ç‚¹åŠ å…¥ä¸€ä¸ªåŸºç¡€å®½åº¦
            pos.w = appSettings.baseWidth; 
            currentStrokePoints.push(pos);
            
            renderCanvas(); // å®æ—¶é‡ç»˜
        }
        
        function move(e) {
            if(!isDrawing) return; 
            e.preventDefault();
            const pos = getVirtualPos(e);
            
            // === å‹æ„Ÿè®¡ç®—é€»è¾‘ ===
            const lastPt = currentStrokePoints[currentStrokePoints.length - 1];
            const dist = Math.hypot(pos.x - lastPt.x, pos.y - lastPt.y);
            const timeDiff = pos.time - lastPt.time;
            
            // é€Ÿåº¦ (pixels/ms)
            const velocity = timeDiff > 0 ? dist / timeDiff : 0;
            
            // åŠ¨æ€å®½åº¦ç®—æ³•: é€Ÿåº¦è¶Šå¿«ï¼Œå®½åº¦è¶Šç»†
            // ç³»æ•° 2 æ˜¯ç»éªŒå€¼ï¼Œå¯å¾®è°ƒ
            let targetWidth = appSettings.baseWidth * (1 - velocity * appSettings.pressure * 0.5); 
            // é™åˆ¶æœ€å°å®½åº¦
            targetWidth = Math.max(targetWidth, appSettings.baseWidth * 0.2);
            
            // å¹³æ»‘å¤„ç†ï¼šæ–°å®½åº¦ = æ—§å®½åº¦ * 0.6 + æ–°ç›®æ ‡ * 0.4
            pos.w = lastPt.w * 0.6 + targetWidth * 0.4;

            currentStrokePoints.push(pos);
            renderCanvas(); 
        }
        
        function end(e) {
            if(!isDrawing) return; 
            isDrawing = false;
            
            // === é”¥åº¦å¤„ç† (Tapering) ===
            // ç»“æŸåå¯¹æ•´æ¡çº¿çš„å¤´å°¾è¿›è¡Œä¿®é¥°
            if (currentStrokePoints.length > 5 && appSettings.taper > 0) {
                const len = currentStrokePoints.length;
                const taperLen = Math.floor(len * appSettings.taper * 0.5); // å•ä¾§é”¥åº¦é•¿åº¦
                const maxTaper = Math.min(taperLen, 10); // é™åˆ¶æœ€å¤§é”¥åº¦ç‚¹æ•°

                for (let i = 0; i < maxTaper; i++) {
                    const factor = (i + 1) / (maxTaper + 1); // 0.1 -> 1.0
                    // å¤´éƒ¨å˜ç»†
                    currentStrokePoints[i].w *= factor;
                    // å°¾éƒ¨å˜ç»†
                    currentStrokePoints[len - 1 - i].w *= factor;
                }
            }

            const char = charList[currentIndex];
            if (!allGlyphData[char]) allGlyphData[char] = [];
            
            if(currentStrokePoints.length > 1) {
                allGlyphData[char].push({
                    points: JSON.parse(JSON.stringify(currentStrokePoints)), // æ­¤æ—¶ç‚¹é‡Œå·²ç»åŒ…å«äº† w (width)
                    width: appSettings.baseWidth, // ä¿ç•™åŸºç¡€å®½åº¦åšå‚è€ƒ
                    isEraser: isEraser
                });
            }
            renderCanvas();
        }

        function renderCanvas() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const char = charList[currentIndex];
            const savedStrokes = allGlyphData[char] || [];
            
            // åˆå¹¶å·²ä¿å­˜çš„ç¬”ç”»å’Œå½“å‰æ­£åœ¨ç”»çš„ç¬”ç”»
            const strokesToRender = [...savedStrokes];
            if (isDrawing && currentStrokePoints.length > 0) {
                strokesToRender.push({
                    points: currentStrokePoints,
                    isEraser: isEraser,
                    width: appSettings.baseWidth
                });
            }

            applyTransform(ctx);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            strokesToRender.forEach(stroke => {
                const pts = stroke.points;
                if (pts.length < 1) return;

                ctx.strokeStyle = stroke.isEraser ? '#ffffff' : '#000000';
                ctx.globalCompositeOperation = stroke.isEraser ? 'destination-out' : 'source-over';

                // === ç»˜åˆ¶å˜å®½çº¿æ¡ (æ¨¡æ‹Ÿ) ===
                // Canvas åŸç”Ÿ stroke ä¸æ”¯æŒå˜å®½ï¼Œä¸ºäº†æ€§èƒ½å’Œæ•ˆæœï¼Œè¿™é‡Œä½¿ç”¨â€œåœ†ç‚¹+è¿çº¿â€æ··åˆ
                // æˆ–è€…ç®€å•ä½¿ç”¨ lineTo ä½†ä¸æ–­æ”¹å˜ lineWidth (æ•ˆæœä¸€èˆ¬ä¼šæ–­è£‚)
                // æœ€ä½³æ–¹æ¡ˆæ˜¯ç»˜åˆ¶è·¯å¾„è½®å»“ï¼Œä½†å¤ªæ…¢ã€‚
                // å¦¥åæ–¹æ¡ˆï¼šæ¯æ®µç”»ä¸€æ¡çº¿ï¼Œå®½åº¦å–ä¸¤ç‚¹å¹³å‡å€¼
                
                for (let i = 0; i < pts.length - 1; i++) {
                    const p1 = pts[i];
                    const p2 = pts[i+1];
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    
                    // ä½¿ç”¨ä¸¤ç‚¹å¹³å‡å®½åº¦
                    // å¦‚æœæ˜¯æ©¡çš®æ“¦ï¼Œå›ºå®šä½¿ç”¨åŸºç¡€å®½åº¦
                    ctx.lineWidth = stroke.isEraser ? stroke.width : (p1.w + p2.w) / 2;
                    ctx.stroke();
                    
                    // è¡¥åœ†å¤´é˜²æ­¢æ–­è£‚
                    ctx.beginPath();
                    ctx.arc(p2.x, p2.y, ctx.lineWidth/2, 0, Math.PI*2);
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.fill();
                }
            });
            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';
        }

        // ================= 6. TTF ç”Ÿæˆç®—æ³• (æ”¯æŒå˜å®½) =================
        
        function generateAndDownloadFont() {
            const glyphs = [];
            const notdefPath = new opentype.Path();
            notdefPath.moveTo(200, 0); notdefPath.lineTo(200, 700); notdefPath.lineTo(800, 700); notdefPath.lineTo(800, 0); notdefPath.close();
            glyphs.push(new opentype.Glyph({ name: '.notdef', unicode: 0, advanceWidth: 1000, path: notdefPath }));
            
            const SCALE = 1000 / CANVAS_SIZE;

            for (let char in allGlyphData) {
                const strokes = allGlyphData[char];
                if (!strokes || strokes.length === 0) continue;
                const fontPath = new opentype.Path();
                const unicodeVal = char.codePointAt(0);

                strokes.forEach(stroke => {
                    if (stroke.isEraser) return; 
                    const pts = stroke.points;
                    if (pts.length < 2) return;

                    const leftSide = [], rightSide = [];
                    for (let i = 0; i < pts.length - 1; i++) {
                        const p1 = pts[i];
                        const p2 = pts[i+1];
                        let dx = p2.x - p1.x, dy = p2.y - p1.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        if (len === 0) continue;
                        
                        const nx = -dy / len, ny = dx / len;
                        const toFontX = (cx) => cx * SCALE;
                        const toFontY = (cy) => (CANVAS_SIZE - cy) * SCALE - 200;
                        
                        const w1 = (p1.w || stroke.width) / 2;
                        const w2 = (p2.w || stroke.width) / 2;

                        leftSide.push({ x: toFontX(p1.x + nx * w1), y: toFontY(p1.y + ny * w1) });
                        rightSide.push({ x: toFontX(p1.x - nx * w1), y: toFontY(p1.y - ny * w1) });

                        if (i === pts.length - 2) {
                            leftSide.push({ x: toFontX(p2.x + nx * w2), y: toFontY(p2.y + ny * w2) });
                            rightSide.push({ x: toFontX(p2.x - nx * w2), y: toFontY(p2.y - ny * w2) });
                        }
                    }

                    if (leftSide.length > 0) {
                        fontPath.moveTo(leftSide[0].x, leftSide[0].y);
                        for (let k = 1; k < leftSide.length; k++) fontPath.lineTo(leftSide[k].x, leftSide[k].y);
                        for (let k = rightSide.length - 1; k >= 0; k--) fontPath.lineTo(rightSide[k].x, rightSide[k].y);
                        fontPath.close();
                    }
                });

                glyphs.push(new opentype.Glyph({
                    name: 'uni' + unicodeVal.toString(16).toUpperCase(),
                    unicode: unicodeVal,
                    advanceWidth: 1000,
                    path: fontPath
                }));
            }

            const font = new opentype.Font({
                familyName: appSettings.fontNameEn,
                styleName: 'Regular',
                unitsPerEm: 1000,
                ascender: 800,
                descender: -200,
                glyphs: glyphs
            });
            font.names.fontFamily.en = appSettings.fontNameEn;
            font.names.fullName.en = appSettings.fontNameEn;
            
            // ===== æ›¿æ¢åŸæœ‰çš„ font.download() ä¸ºæ‰‹åŠ¨ä¸‹è½½ =====
            try {
                const buffer = font.toArrayBuffer();
                const blob = new Blob([buffer], { type: 'application/font-sfnt' }); // TTF çš„ MIME ç±»å‹
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (appSettings.fontNameEn || 'MyHandwriting') + '.ttf'; // å¼ºåˆ¶ä½¿ç”¨ .ttf æ‰©å±•å
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (e) {
                alert('å­—ä½“ç”Ÿæˆå¤±è´¥ï¼š' + e.message);
            }
        }
        // ================= é€šç”¨è¾…åŠ© =================
        function updateUI() {
            if(!charList || charList.length === 0) return;
            if (currentIndex >= charList.length) currentIndex = charList.length - 1;
            
            const realChars = Array.from(charList);
            const char = realChars[currentIndex];
            document.getElementById('charSeq').innerText = char;
            const unicodeHex = char.codePointAt(0).toString(16).toUpperCase().padStart(4, '0');
            document.getElementById('glyphName').innerText = `U+${unicodeHex}`;
            document.getElementById('progressText').innerText = `${currentIndex + 1} / ${realChars.length}`;
            renderCanvas();
        }

        function drawGrid() {
            gridCtx.clearRect(0,0,320,320); 
            applyTransform(gridCtx);
            gridCtx.strokeStyle='#ffcccc'; 
            gridCtx.lineWidth= 1 / canvasScale;
            gridCtx.strokeRect(0,0,320,320);
            gridCtx.beginPath();
            gridCtx.moveTo(160,0); gridCtx.lineTo(160,320);
            gridCtx.moveTo(0,160); gridCtx.lineTo(320,160);
            gridCtx.moveTo(0,0); gridCtx.lineTo(320,320);
            gridCtx.moveTo(320,0); gridCtx.lineTo(0,320);
            gridCtx.stroke();
            gridCtx.restore();
        }

        function initCanvasEvents() {
            canvas.addEventListener('mousedown', start); canvas.addEventListener('mousemove', move);
            canvas.addEventListener('mouseup', end); canvas.addEventListener('mouseout', () => isDrawing=false);
            canvas.addEventListener('touchstart', start, {passive:false}); canvas.addEventListener('touchmove', move, {passive:false});
            canvas.addEventListener('touchend', end);
        }

        window.closeDialog = (id) => document.getElementById(id).classList.remove('active');
        
        // é¢„è§ˆ SVG ç”Ÿæˆ
        document.getElementById('canvasListButton').onclick = function() {
            const container = document.getElementById('preview-grid');
            container.innerHTML = '';
            const fragment = document.createDocumentFragment();
            const realChars = Array.from(charList);

            for (let i = 0; i < realChars.length; i++) {
                const char = realChars[i];
                const cell = document.createElement('div');
                cell.className = 'char-cell';
                const strokes = allGlyphData[char];

                if (strokes && strokes.length > 0) {
                    cell.classList.add('done');
                    let svgPaths = '';
                    strokes.forEach(s => {
                        const color = s.isEraser ? '#ffffff' : '#000000';
                        if(s.points && s.points.length > 0) {
                            let d = `M ${s.points[0].x} ${s.points[0].y}`;
                            // é¢„è§ˆæ—¶ç®€å•åŒ–ï¼Œä¸ç”»å˜å®½æ•ˆæœä»¥æé«˜æ€§èƒ½ï¼Œæˆ–è€…å–å¹³å‡å®½
                            for(let k=1; k < s.points.length; k++) d += ` L ${s.points[k].x} ${s.points[k].y}`;
                            // SVG é¢„è§ˆå–ç¬¬ä¸€ç‚¹çš„å®½åº¦åšå‚è€ƒ
                            const avgW = s.width; 
                            svgPaths += `<path d="${d}" stroke="${color}" stroke-width="${avgW}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
                        }
                    });
                    cell.innerHTML = `<svg viewBox="0 0 320 320">${svgPaths}</svg>`;
                } else {
                    cell.innerText = char;
                }
                
                if (i === currentIndex) cell.classList.add('current');
                cell.onclick = () => { currentIndex = i; updateUI(); closeDialog('listup-container'); };
                fragment.appendChild(cell);
            }
            container.appendChild(fragment);
            document.getElementById('listup-container').classList.add('active');
        };

        // æŒ‰é’®äº‹ä»¶
        document.getElementById('undoButton').onclick = () => { const char = Array.from(charList)[currentIndex]; if(allGlyphData[char]) { allGlyphData[char].pop(); renderCanvas(); } };
        document.getElementById('clearButton').onclick = () => { const char = Array.from(charList)[currentIndex]; allGlyphData[char] = []; renderCanvas(); };
        document.getElementById('prevButton').onclick = () => { if(currentIndex>0) {currentIndex--; updateUI();} };
        document.getElementById('nextButton').onclick = () => { if(currentIndex<Array.from(charList).length-1) {currentIndex++; updateUI();} };
        document.getElementById('moveLeftButton').onclick = () => moveStrokes(-10, 0);
        document.getElementById('moveRightButton').onclick = () => moveStrokes(10, 0);
        document.getElementById('moveUpButton').onclick = () => moveStrokes(0, -10);
        document.getElementById('moveDownButton').onclick = () => moveStrokes(0, 10);
        document.getElementById('downloadTTFButton').onclick = async () => {
            document.getElementById('loadingMask').style.display = 'flex';
            setTimeout(() => { try { generateAndDownloadFont(); } catch(e) { alert(e.message); } finally { document.getElementById('loadingMask').style.display = 'none'; } }, 100);
        };
        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            canvasScale = parseFloat(e.target.value);
            document.getElementById('zoomValue').innerText = canvasScale.toFixed(1) + 'x';
            drawGrid(); renderCanvas();
        });
        document.getElementById('penButton').onclick = function() { isEraser=false; this.classList.add('active'); document.getElementById('eraserButton').classList.remove('active'); };
        document.getElementById('eraserButton').onclick = function() { isEraser=true; this.classList.add('active'); document.getElementById('penButton').classList.remove('active'); };
        document.getElementById('listSelect').onchange = (e) => {
            if(e.target.value === 'custom') document.getElementById('customDialog').classList.add('active');
            else { currentListKey = e.target.value; charList = charDatasets[currentListKey]; currentIndex = 0; updateUI(); }
        };
        window.applyCustomText = function() {
            const text = document.getElementById('customTextInput').value;
            if(!text) return;
            const uniqueChars = Array.from(new Set(Array.from(text))).filter(c => c.trim() !== '');
            charDatasets['custom'] = uniqueChars.join('');
            currentListKey = 'custom'; charList = charDatasets['custom']; currentIndex = 0;
            closeDialog('customDialog'); updateUI();
        };
        const moveStrokes = (dx, dy) => {
            const char = Array.from(charList)[currentIndex];
            if(!allGlyphData[char]) return;
            allGlyphData[char].forEach(s => s.points.forEach(p => { p.x+=dx; p.y+=dy; }));
            renderCanvas();
        };
    </script>
</body>
</html>